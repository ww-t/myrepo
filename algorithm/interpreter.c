/*
10 개의 레지스터 와 1000 개의 단어를 가진 컴퓨터가 있다.
명령은 3 개의 숫자로 구성되고 각 결과는 램에 저장된다.

명령의 규칙은 다음과 같다.

100	100 은 정지
2dn	d 번 레지스터에 n(0..9) 으로 세트
3dn	d 번 레지스터에 n 을 더함
4dn	d 번 레지스터에 n 을 곱함
5ds	레지스터 d 값을 레지스터 s 값으로 세트
6ds	레지스터 d 값에 레지스터 s 값을 더함
7ds	레지스터 d 값에 레지스터 s 값을 곱함
8da	레지스터 d 값을 레지스터 a 값을 주소로 하는 램의 내용으로
9sa	a번 레지스터의 내용을 주소로 하는 램상의 값을 레지스터 s 의 값으로 변경
0ds	레지스터 s 의 내용이 0 이 아니라면 레지스터 d 를 주소로 하는 램상의 주소로 goto

모든 레지스터는 처음 000 으로 클리어 되어 있고 램상의 모든 내용은 표준입력으로 읽혀지고 , 첫 명령은 램상의 0 번 주소 부터 시작한다.
모든 결과는 1000 으로 나눈 나머지로 계산한다.

입력

3 개의 부호없는 수가 최대 1000 개 까지 입력된다. 차례대로 주소 0 부터 할당된다. 주어지지 않는 램의 주소는 모두 000 으로 간주한다.

출력

멈출 때 까지 실행된 명령의 개수를 출력한다. 반드시 멈춘다는 것은 보장된다.

입출력 예

입력

299
492
495
399
492
495
399
283
279
689
078
100
000
000
000

출력

16
*/

#include <stdio.h>
#include <stdlib.h>

int main(){
    int c=0,i,on,od1,od2,r[10],o[1000];
    
    for(i=0;i<1000;i++){
         o[i]=000;
         if(i<10)
              r[i]=0;
    }
    
    for(i=0;;i++){
         scanf("%d",&o[i]);
         if(o[i]==100)
              break;
    }
    
    for(i=0;o[i]!=100;i++){
         on=o[i]/100;
         od1=o[i]%100/10;
         od2=o[i]%10;
         switch(on){
         case 2:
              r[od1]=od2;
              break;
         case 3:
              r[od1]=(r[od1]+od2)%1000;
              break;
         case 4:
              r[od1]=(r[od1]*od2)%1000;
              break;
         case 5:
              r[od1]=r[od2];
              break;
         case 6:
              r[od1]=(r[od1]+r[od2])%1000;
              break;
         case 7:
              r[od1]=(r[od1]*r[od2])%1000;
              break;
         case 8:
              r[od1]=o[r[od2]];
              break;
         case 9:
              o[r[od2]]=r[od1];
              break;
         case 0:
              if(r[od2]!=0)
                   i=r[od1]-1;
              break;
         }
         c++;
    }
    
    printf("%d\n",c+1);
    
    system("pause");
    return 0;
}
