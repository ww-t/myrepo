/*
1949년 인도 수학자 Kaprekar 는 Kaprekar 연산을 고안해냈다.
Kaprekar 연산은 네 자리 수 중 모든 자리수가 같지 않은 수(1111, 2222 등을 제외한)의 각 자리의 숫자를 재배열해서 만들 수 있는
가장 큰 수와 가장 작은 수를 만들어서 그 차이를 계산하는데, 그 결과로 나온 새로운 숫자를 갖고 같은 과정을 반복하는 것이다.

간단한 연산이지만 Kaprekar 는 이 연산이 놀라운 결과를 보여준다는 것을 발견했다.
올해 연도인 2008 로 그 결과를 알아보자. 2008 로 만들 수 있는 가장 큰 수는 8200 이고 가장 작은 수는 0028 이다.

8200 - 0028 = 8172 
8721 - 1278 = 7443 
7443 - 3447 = 3996 
9963 - 3699 = 6264 
6642 - 2466 = 4176 
7641 - 1467 = 6174 
7641 - 1467 = 6174 

6174 에 도달한 다음에는 매번 6174 를 만들어 낸다.
2008 만이 유독 6174 에 도달하는 것이 아니라 한 숫자로 이루어지지 않은 모든 네 자리 수는 Kaprekar 연산을 통해 6174 로 가게 된다.
2008 의 경우 6 단계를 거쳐 6174 로 가게 되었는데, 다른 숫자가 입력으로 주어졌을 때 몇 단계 만에 6174 로 가는지 알아내는 프로그램을 작성하시오.

입력

한 줄에 네 자리 수(1000~9999)가 하나씩 주어진다. 단, 이 숫자는 1111, 2222 처럼 하나의 숫자로 이루어진 수는 제외한다.

출력

Kaprekar 연산을 통해 몇 단계 만에 6174가 되는지 출력하시오.

입출력 예

입력

6174 

출력

0 

입력

1789 

출력

3 

입력

2005 

출력

7 
*/

#include <stdio.h>
#include <stdlib.h>

int main()
{
    int x,i,m,n,c,a[4];
    
    scanf("%d",&x);
    
    for(i=0;x!=6174;i++)
    {
                        a[0]=x/1000;
                        a[1]=x%1000/100;
                        a[2]=x%100/10;
                        a[3]=x%10;
                        
                        for(m=0;m<4;m++)
                        {
                                        for(n=m+1;n<4;n++)
                                        {
                                                          if(a[m]>a[n])
                                                          {
                                                                       c=a[n];
                                                                       a[n]=a[m];
                                                                       a[m]=c;
                                                          }
                                        }
                        }
                        
                        x=(a[3]*1000+a[2]*100+a[1]*10+a[0])-(a[0]*1000+a[1]*100+a[2]*10+a[3]);
    }
    
    printf("%d\n",i);
    
    system("pause");
    return 0;
}
